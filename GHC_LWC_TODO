* -----------------------------------------------------------------------------
* Implementing sleep/wakeup capabilities -- HIGH
* -----------------------------------------------------------------------------

* -----------------------------------------------------------------------------
* Block action blocking on a blackhole within a PTM -- HIGH
* -----------------------------------------------------------------------------

Must implement block action blocking on a blackhole. For blocking on a different
capability, we must create block and unblock actions using sleepCapability and
wakeupCapability. For blocking on current capability, we need to build AP_STACK.

* -----------------------------------------------------------------------------
* Work initiation on other capabilities -- LOW
* -----------------------------------------------------------------------------

Currently, the substrate primitive scheduleSContOnFreeCap :: SCont -> IO () is
used to initiate task execution on other capabilities. But this method is not
robust. If there are no free capabilities, the call does not return!! Need

newCap :: SCont -> IO ()

which spins up a new capability..

* -----------------------------------------------------------------------------
* SwitchTO return value
* -----------------------------------------------------------------------------

Since switchTo eagerly returns from a transaction with the value (), it might
not be the same type as the value expected by the continuation of the atomic
section. Hence, switchTo should return a value (error "eager return"). This will
make sure that any attempt to use the return value will throw a runtime error.

Soln: Make switchTo return a (error "Eagerly returned transaction. Result must
be ignored"). This needs to be a default closure that can be found from the C--
code.


* -----------------------------------------------------------------------------
* SCont status
* -----------------------------------------------------------------------------

data SContStatus = SContRunning | SContKilled | SContCompleted
                 | SContBlocked BlockReason
data BlockReason = Yielded | BlockedInRTS | BlockedInHaskell

getSContStatus :: SCont -> SContStatus
setBlockReason :: BlockReason -> PTM ()


* -----------------------------------------------------------------------------
* Default Scheduler
* -----------------------------------------------------------------------------

How do we implement default scheduler? How can we build pluggable schedulers?
The latter is a problem of dynamic linking.
